.program ms

.define public SkippedCycles 10 -1 ; to get comparator out of saturation (-1 due to the architecture)

; don't forget to enable auto push/pull

; PIO PWM Multislope pseudocode by NNNI, turned in to real code by dimin
; Give him some credit, at least he tried to read the PIO documentation
    mov X, !NULL                    ; set X to 0xFFFFFFFF
    pull                            ; pull the Y FIFO
    out Y, 32                       ; read the number desired counts
    jmp start
rundown:
    set pins 0
    in X, 32
    pull                            ; stall
start:
irq wait 0 ; remove this if debug clock is off            
.wrap_target
	set pins 2                      ; set PWMA high, and PWMB low                    [01 clock cycles]
	jmp pin PWMhigh                 ; read comparator input, jump to pwm high state  [01 clock cycles]
	jmp X-- PWMlow                  ; else jump to PWM low state                     [01 clock cycles] (if pin is low we decrement X)
PWMhigh:
	set pins 2  [19]                ; keep PWMA high             [02 clock cycles] + [20 clock cycles]
	set pins 1                      ; set PWMA low, at the same time PWMB high       [01 clock cycles]
    jmp end                         ; go to the end of cycle                         [01 clock cycles] (22)
PWMlow:
    set pins 2  [6]                 ; keep PWMA high                [03 clock cycles] + [7 clock cycles]
	set pins 1  [13]                ; set PWMA low                  [10 clock cycles] + [12 clock cycles](22)
end:
	jmp Y-- skip    [3]             ; when we reached counts go to rundown           [01 clock cycles]
    jmp rundown
skip:
nop                                 ; total                                          [32 clock cycles]
.wrap 

;rundown
; start:
; 	set PWMA 1                [16] ; turn on PWMA for 16 clock cycles (5us)         [16 clock cycles]
; 	set PWMA 0        side 1       ; turn off PWMA, turn on PWMB at the same time   [01 clock cycles]
; 	jmp count                      ; unconditional jump to count                    [01 clock cycles]
; count:
; 	jump COMP start                ; if comparator is high, keep counting           [01 clock cycles]
; 	set PMA 0         side 0       ; turn off both pins after rundown is complete   [01 clock cycles]
	
; oh shit I forgot counting again, but eh
; also totally forgot the role of the input pin, but you know what to do now lmao




            

% c-sdk {

// Helper function (for use in C program) to initialize this PIO program
void ms_program_init(PIO pio, uint sm, uint offset, uint pin, uint input, float div) {

    // Sets up state machine and wrap target. This function is automatically
    pio_sm_config c = ms_program_get_default_config(offset);

    // set the pin for jump if pin high instruction
    sm_config_set_jmp_pin(&c, input); 
    // Connect pin to SET pin (control with 'set' instruction)
    sm_config_set_set_pins(&c, pin, 2);

    // Set the pin direction to output (in PIO)
    pio_sm_set_consecutive_pindirs(pio, sm, pin, 2, true);
    
    // Set auto push and pull from OSR and ISR
    sm_config_set_in_shift(&c, false, true, 32);
    //sm_config_set_out_shift(&c, false, false, 32);

    // Set the clock divider for the state machine
    sm_config_set_clkdiv(&c, div);

    // Allow PIO to control GPIO pin (as output)
    pio_gpio_init(pio, pin);
    pio_gpio_init(pio, pin+1);

    // Load configuration and jump to start of the program
    pio_sm_init(pio, sm, offset, &c);
}

%}